<!doctype html>
<html lang="en">
    <head>
        <title>
            Shader Circle Inversion
        </title>
        <meta charset="utf-8">

        <!-- Instruct mobile devices to render entire page just as a desktop browser would (i.e. no scrollbars). -->
		<meta
            name="viewport"
            content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

        <script type="x-shader/x-vertex" id="vertexshader">

		    // Switch on high precision floats.
		    #ifdef GL_ES
		        precision highp float;
		    #endif

            // Just perform normal view/model/projection transformation to screen.
		    void main()
		    {
			    gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
		    }
	    </script>
        <script type="x-shader/x-fragment" id="SpiralOfMadnessFragmentShader">

		    // Switch on medium precision floats.
            #ifdef GL_ES
            precision mediump float;
            #endif

            // Define two critical uniforms set from the JavaScript proper.
            uniform float time;
            uniform vec2 resolution;

            void main (void)
            {
                // Spiral of madness.
                vec2 p = (gl_FragCoord.xy / resolution.xy) - 0.5;
                float c = 0.0;
                float a = atan(p.x,p.y)*10.;
                float d = 8.0 / length(p);
                c = (atan(cos(d-a+time)*20.)*9./pow((d),1.15));
                gl_FragColor = vec4( vec3(2.0,1.5,8.0)*vec3( c*c, c*c-c, c*c*c/(1.0+c) ), 1.0 );
            }
        </script>
        <script type="x-shader/x-fragment" id="CircleInversionFragmentShader">

		    // Switch on medium precision floats.
            #ifdef GL_ES
                precision mediump float;
            #endif

            // Define two critical uniforms set from the JavaScript proper.
            uniform float time;
            uniform vec2 resolution;
            uniform vec2 aspectstretch;
            uniform vec2 scale;
            uniform vec2 cycleoffset;
            uniform float reflectionradius;
            uniform vec3 colorfactors;

            // Define inversion sub-routine from the definition
            // as specified by Apollonius of Perga circa ~200 BC.
            vec2 CircleInversion(vec2 vPos,
                vec2 vOrigin,
                float fRadius)
            {
                // Define a ray from the origin to the specified position.
	            vec2 vOP = vPos - vOrigin;

                // Choose a point along the ray.
	            vOrigin = vOrigin - vOP * fRadius / dot(vOP, vOP);
	            // Used to be: vOrigin = vOrigin - vOP * fRadius * fRadius / dot(vOP, vOP);?

                // Reflect about the circumfrence.
	            vOrigin.x += sin(vOrigin.x * aspectstretch.x);
	            vOrigin.y -= cos(vOrigin.y * aspectstretch.y);

                // Return.
	            return vOrigin;
            }

            // Main method: normalizes fragment position,
            // chooses a point on the circle, recursively
            // iterates its inversion and ouputs to geometry.
            void main(void)
            {
                // Get position in [-0.5..0.5].
	            vec2 vPos = gl_FragCoord.xy / resolution.xy - 0.5;

                // Adjust for aspect ratio.
	            vPos.x *= resolution.x / resolution.y;

                // Choose a time-based point on or around the circle as a re-entrant fractal seed.
                // Notice the X parameter of the offset is sinusoidal, and the Y parameter is tangental.
	            vec2 vOffset = vec2(sin(time * cycleoffset.x),
                    atan(time * cycleoffset.y));

                // Iterate the fractal.
                for (int i = 0; i < 32; i++)
	            {
                    // This abs call is critical to getting the kaleidoscope effect.
		            vPos.x = abs(vPos.x);

                    // Here, each iteration is bounced around the circle.
		            vPos = vPos * scale + vOffset;

                    // Call down to the inversion routine--this evicerates the circle, exposing structure.
                    // Notice that the circle inversion takes the output position as an input parameter.
		            vPos = CircleInversion(vPos,
                        vec2(0.5,
                            0.5),             // The center.
                        reflectionradius);    // Magic number.  Too small -> mush.  Too big -> mush.  Just right -> awesome!
	            }

                // Cycle the colors...slowly.
	            float fR = sin(time / 2.0 * colorfactors.x);
	            float fG = cos(time / 2.0  * colorfactors.y);
	            float fB = sin(time / 2.0  * colorfactors.z);

                // Normalize to get into full color space.
	            vec3 vBaseColor = normalize(vec3(fR / 2.2 + 0.4,
                    fG / 2.2 + 0.4,
                    fB / 2.2 + 0.4));

                // Position length is critical to differentiating the intensity of the shape.
                float fPosLength = length(vPos);
	            vec3 vColor = vBaseColor * fPosLength;// * fPosLength;

                // Soften up the color slightly.
	            vColor = 1.0 - exp2(-vColor);

                // Finally, output with full opacity.
	            gl_FragColor = vec4(vColor,
                    1.0);
            }
        </script>
        <script src="js/three.min.js"></script>
        <script src="js/OrbitControls.js"></script>
        <script>
            // Ready method invoked when the document is fully loaded.
            document.addEventListener("DOMContentLoaded", () => {

                // Set up the scene, camera, and renderer as global variables.
                var scene,
                    camera,
                    renderer,
                    uniforms = null,                    // "Globalize" uniforms so it may be addressed and updated.
                    startTime = new Date().getTime();   // Remember start time.

                init();
                animate();

                // Sets up the scene.
                function init() {

                    // Create the scene and set the scene size.
                    scene = new THREE.Scene();
                    var WIDTH = window.innerWidth,
                        HEIGHT = window.innerHeight;

                    // Create a renderer and add it to the DOM.
                    renderer = new THREE.WebGLRenderer({

                        antialias: true
                    });
                    renderer.setSize(WIDTH,
                        HEIGHT);
                    document.body.appendChild(renderer.domElement);

                    // Create a camera, zoom it out from the model a bit, and add it to the scene.
                    camera = new THREE.PerspectiveCamera(60,
                        WIDTH / HEIGHT,
                        0.1,
                        20000);
                    camera.position.set(0, 0.85, 0);
                    scene.add(camera);

                    // Create an event listener that resizes the renderer with the browser window.
                    window.addEventListener("resize",
                        function () {

                            // Re-extract size data.
                            var WIDTH = window.innerWidth,
                                HEIGHT = window.innerHeight;

                            // Update the renderer and the camera.
                            renderer.setSize(WIDTH,
                                HEIGHT);
                            camera.aspect = WIDTH / HEIGHT;
                            camera.updateProjectionMatrix();

                            // Update the uniform so next frame is drawn with correct aspect.
                            uniforms.resolution.value = new THREE.Vector2(WIDTH,
                                HEIGHT);
                        });

                    // Define simple plane geometry upon which to display the fractal.
                    var geometry = new THREE.PlaneGeometry(3,
                        1,
                        1,
                        1);

                    // Define uniforms which are passed to the shaders each frame.
                    uniforms = {

                        time: {

                            type: "f",
                            value: (new Date().getTime() - startTime) / 100
                        },
                        resolution: {

                            type: "v2",
                            value: new THREE.Vector2(WIDTH,
                                HEIGHT)
                        },
                        aspectstretch: {

                            type: "v2",
                            value: new THREE.Vector2(0.1,
                                0.1)
                        },
                        scale: {

                            type: "v2",
                            value: new THREE.Vector2(1.25,
                                1.25)
                        },
                        cycleoffset: {

                            type: "v2",
                            value: new THREE.Vector2(0.00123,
                                0.00567)
                        },
                        reflectionradius: {

                            type: "f",
                            value: 0.99
                        },
                        colorfactors: {

                            type: "v3",
                            value: new THREE.Vector3(0.05,
                                0.03,
                                0.07)
                        }
                    };

                    const shader = document.getElementById("vertexshader");
                    const fragment = document.getElementById("CircleInversionFragmentShader");
//                    const fragment = document.getElementById("SpiralOfMadnessFragmentShader");

                    // Create the shader material.
                    var shaderMaterial = new THREE.ShaderMaterial({

                        uniforms: uniforms,
                        vertexShader: shader.innerText,
                        fragmentShader: fragment.innerText
                    });

                    // Allocate the mesh which is added to the scene.
                    var mesh = new THREE.Mesh(geometry,
                        shaderMaterial);
                    mesh.rotateX(-Math.PI / 2);
                    scene.add(mesh);

                    // Add OrbitControls to pan around with the mouse.
                    controls = new THREE.OrbitControls(camera,
                        renderer.domElement);
                    controls.enabled = false;
                }

                // Renders the scene and updates the render as needed.
                function animate() {

                    // If uniforms allocated, update time.
                    if (uniforms !== null) {

                        uniforms.time.value = (new Date().getTime() - startTime) / 100;
                    }

                    // Render the scene.
                    renderer.render(scene,
                        camera);
                    controls.update();

                    // Schedule next frame.
                    requestAnimationFrame(animate);
                }
            });
        </script>
    </head>
    <body style="margin: 0; overflow: hidden;">
    </body>
</html>
